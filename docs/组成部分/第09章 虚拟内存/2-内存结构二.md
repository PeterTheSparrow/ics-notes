---
title: 第二节 内存结构二
sidebar_position: 2
---

import OfficePreview from '@site/src/components/OfficePreview/index';

<OfficePreview place = "/ppt/2-11-locality.ppt"/>

## 内存结构二

### 一、局部性

#### 1）局部性现象

- 局部性有两种，参考下面的代码

```c
int sumvec(int v[N])
{
	int i, sum = 0 ;
	
	for (i = 0 ; i < N ; i++)
		sum += v[i] ;
	return sum ;
}
```

- 一个变量反复被访问，例如`sum`还有`i`，这个叫做**时间局部性**（在一段时间连续被多次访问）
- 数组元素被顺序的访问，连续访问的是相邻的地址（这个叫做**空间局部性**，一个地址被访问过以后，那么它相邻的地址就会在不久的将来被访问）

#### 2）Stride-1

- 代表跨度为1，比如连续访问下面的数组

```c
int sumarrayrows(int a[M][N]) //M=2,N=3
{
	int i, j, sum = 0 ;
	
	for (i = 0 ; i < M ; i++)
		for ( j = 0 ; j < N ; j++ )
			sum += a[i][j] ;
	return sum ;
}

```

#### 3）Stride-N

- 代表跨度为N，比如把上面的数组两个循环体交换一下
- 现在就变成了Stride-3

```c
int sumarraycols(int a[M][N]) //M=2,N=3
{
	int i, j, sum = 0 ;
	
	for (j = 0 ; j < N ; j++)
		for ( i = 0 ; i < M ; i++ )
			sum += a[i][j] ;
	return sum ;
}
```

### 二、内存

#### 1）存储天梯图

- 我们实际上是做了一个叫做 storage pool， storage pool 是一个池子，这个池子里头把所有这些东西都放进去
- 上头的存储都比较小，它总价就不会那么贵（但是访问速度快）
- 访问速度是比较接近于金字塔塔尖上头的，让我们感觉来讲的基本上还都是每次访问都是很快
- 注意：用了这个池子以后，它最终它的容量并不是说是把这些容量加起来得到一个总的容量！我们存储的容量是最底层的，上面的那些东西都是用来作为缓存使用的！上一级的，都是下一级的这个存储数据的一个子集
- 为什么浪费掉上头这个存储容量？主要是我们要获得速度！

![截屏2023-04-16 11.48.05](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2011.48.05.png)

#### 2）缓存概念

- 缓存Block：上下不同层级的都是用的Block进行划分（跟前面SSD Block、Disk Block不是一个概念！）
- 如下图所示，Block越往上的数量越少，越往下数量越大。不同层级的Block的大小可能也不一样，DRAM和Disk的块的大小可能是4K-1G的大小，但是寄存器是64K【这里有一个补充说明，第 $K-1$ 层Cache和第K层要约定好交互的 $Block(1)$，这个必须要一致的，同样的第 $K+1$ 层Cache和第 $K$ 层要约定好交互的 $Block(2)$，但是 $Block(1)$ 和 $Block(2)$ 大小不一定需要相同，需要相同的相邻两层交互的Block需要一致】

![截屏2023-04-16 11.55.32](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2011.55.32.png)

- 缓存命中：假如我要访问14，那这个时候缓存就会命中了！（注意一个Block里面可能有很多个数据，这就体现了我们的局部性，比如我们访问连续的几个元素，可能就都在一个Block里面）
- 缓存Miss：假如我要访问13，发现这个时候没有，这时候就需要把下层的13搬到上层来，搬上来后有两个策略：
  - 替换策略：如果满了会考虑一些策略，踢出旧的数据快
  - 存放策略：比如新来的Block存放在哪个数据块
  - 所以Miss的时候会有很多事情要做
- 综合考虑这样带来速度的提升，就会接近顶层的访问速度
- Miss有下面几个种类：
  - Cold (compulsory) miss：缓存是空的
  - capacity miss：我要访问的数据比缓存的数据集合要大，这时肯定是Miss会发生
  - Conflict miss：这个需要举例子。假如第K层缓存有四个位置，编号为0、1、2、3，然后K+1层缓存有16个位置，分别为0-15。其中第K层的第 i 个位置只能存放第 K+1 层的 i % 4 的位置（也就是说上一层的0只能存放下一层的Block0、4、8、12，以此类推）那么假如我连续访问0、4、0、4，这就导致第K层缓存的0号位置不断的换进换出，这就导致了Conflict miss

> 为什么层次化的内存结构有效？
> - 因为上层存放的都是经常访问的数据（都是下层数据的子集），这样提高了读取的速度。

> 为什么CPU有多级缓存？
>
> - 最早的时候，只有三层缓存：CPU/寄存器、Cache、然后Memory（三级）
> - IBM后来发现了局部化原理，就做的这一层Cache
> - 等到80年代，发现CPU越来越快，Memory越来越大。Cache面临一个困难就是：既需要更大的容量也需要更大的空间，做大了以后，它访问就慢（而CPU速度越来越快），做小了满足不了空间需要（容量匹配不了Memory，因为Memory的空间更大），所以就拆成了多级CPU缓存。
> - 所以CPU访问内存的时候，依次访问L1、L2、L3，都找不到的时候才访问Memory

### 三、内存访问过程

#### 1）内存访问概述

- 首先去缓存里面找，找到了就叫命中
- 如果没找到，就执行miss的处理机制

#### 2）参数介绍

- 如下所示是内存缓存的组织结构，有几个参数
- S：代表的是所有的集合数量，集合的个数为S个，一般是2的幂次
- E：代表每个集合里面有若干个行，不要求2的幂次
- B：代表Block的Size，一般是2的幂次
- 下图里面valid代表数据是否是有效的，要是0，整个这一行是作废的，比如计算机刚刚启动的时候
- Tag的作用？Cache是Memory的一个子集，所以Memory里面可能有不同的地址A1、A2，他们可能对应到同一个Set甚至同一个Line，怎么区分捏？就要依靠Tag
- Block里面存放的就是有效的数据

![截屏2023-04-16 13.51.18](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2013.51.18.png)

#### 3）Direct-Mapped Caches

- 先从最简单的开始介绍，也就是每一个Set里面都只有一个Line的情况
- 访问分为三个步骤：Set selection、Line matching、Word Extraction
- 我们可以把物理地址分为三个部分：

![截屏2023-04-16 14.16.22](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.16.22.png)

- 前面t位代表的是Tag位，然后s为代表的set的编号，然后最后是Block的偏移量

访问的三个步骤如下：

- 首先根据 set index ，找到对应的集合编号，如下图所示

![截屏2023-04-16 14.17.53](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.17.53.png)

- 然后进行Line Match，Line Match需要保证两个：
  - 第一保证是有效的数据，valid位必须是1
  - 然后要保证Tag位和物理地址的`<tag>`是匹配的

![截屏2023-04-16 14.18.30](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.18.30.png)

- 最后进行Word Extraction：
  - 读取的位数是根据指令来的，比如`movl`就是读取的8Byte
  - 读取的偏移量是根据物理地址的`block offset`

![截屏2023-04-16 14.19.47](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.19.47.png)

- 补充：假如在上图里面读取的offset是1100，那这个时候读取的范围越界了？怎么办？这就取决于CPU厂家了，Intel会自动处理这种错误。

#### 4）Miss的处理

- 假如发生了Cache的Miss，怎么处理？分为两种情况：
- 第一种情况，valid位是1，也就是说缓存里面的数据是有效的。我们需要把数据淘汰掉。淘汰也要具体情况
  - 假如这个数据我们经过了修改，那我们还需要把他写回去内存
  - 如果没有修改，才能直接覆盖
- 第二种情况，valid位是0，缓存数据无效。无效的比较简单，只要把这个数据拿来给它填上就可以了，
- 总之，有新的数据会把这个位置填掉。

> Miss的处理机制：我们上一个部分Word Extraction里面，是通过偏移量访问的，那假如Miss了，我们要读取的数据可不仅仅是要访问的数据，而是要把整个Block都填充满，这样才能达到我们局部最优性的目标

- 那么遇到Miss，第一件事情就是要把block offset清空

![截屏2023-04-16 14.33.00](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.33.00.png)

- 然后把地址放到Bus上面，假如整个Block有64Byte，我们Main memory 每次都只能返回8Byte，那么整个过程就需要重复8次，才能得到64Byte

#### 5）概念整理

- Block：存放的数据
- Line：一个集合里面包含的多个Line，每个Line里面包含Block和其他的信息
- Set：多个Line的集合

#### 6）Conflict Misses

- 假设有这样一段代码

```c
float dotprod(float x[8], float y[8])
{
  float sum = 0.0;
  int i;
  for (i = 0; i < 8; i++)
    sum += x[i] * y[i];
  return sum;
}
```

- 相关元素的地址如下所示

```
// 假设block is 16 bytes，可以存放四个float数字
// 地址 tag(3) set(1) block(4)
```

![截屏2023-04-16 14.53.29](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2014.53.29.png)

- 这个时候，访问 $x[0]$ 的时候，会连带这个吧 $x[0]-x[3]$ 一起拉出来
- 但是我接下来要访问的是 $y[0]$
- 所以出现Miss

- 解决方法就是：我把 $y[0]$ 地址放在48的地址，这样就正好错开了

![截屏2023-04-16 15.00.17](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2015.00.17.png)

#### 7）set放中间

> 问题：set index的地址为什么要放在中间？
>
> - 假如把物理地址依次切分为`[set index|tag|block offset]`
> - 显然我们知道最高的位置set index肯定是变的最慢的
> - 那假如我们连续读取一段内存地址（首先变的比较快的就是tag位置，然后变的就是set index），最高位的set index变的最慢，而我们这个例子是每个set只有一个line那发生冲突的情况就大大增加。
> - 相反，假如我们把set index放在中间
> - 那访问的时候，set index变的就比较快，`[0,n-1],[n,2n-1]` 的数据可能就正好放在了两个不同的set里面

- 看下面的例子，这个index bit放在中间的情况：

![截屏2023-04-16 15.11.37](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2015.11.37.png)

- 下面这个例子就是，index bit放在最前，可以发现如果顺序访问的01、23地址的时候，会发生Conflict冲突Miss

![截屏2023-04-16 15.11.56](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2015.11.56.png)

#### 8）set中有多个Line

- 好处就是避免了Conflict Miss。
- 具体步骤和上面的一样，需要比较不同的Line的Tag是否一样
- 唯独的区别是如下图所示，比如下面的有两个Line，在确保valid位是1的情况下，需要保证tag位匹配就可以

![截屏2023-04-16 15.14.40](./2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BA%8C.assets/%E6%88%AA%E5%B1%8F2023-04-16%2015.14.40.png)

#### 9）淘汰策略

- 当出现Miss的时候，每个Set里面可能有多个Line，那我选择哪一个淘汰？
- 方法一：LFU (least-frequently-used)，需要记录过去的一段时间，访问次数最少的需要被淘汰掉
- 方法二：LRU (least-recently-used)，淘汰掉距离当前时间最早的访问的哪那一行。假如我访问的Line1、Line1、Line2、要淘汰的时候，按照Line1是距离当前时间最久远的，那就淘汰Line1、，但是如果LFU的话，Line2就会被淘汰





