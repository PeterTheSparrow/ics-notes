---
title: 第四节 流水线
---

## 第四节 流水线

> 导言：洗车有多种选择，自己洗车这种就叫串行。一个人把这个车的整个部分都洗一遍擦一遍，那当然这是一个人。再有就是工厂化的这种自动化的洗车，把这个车就推进去，推进去以后车就往前走，走到不同的地方，他把车的不同的部分给洗一下，这个这样就在这个我们的流水线操作，从进去到出来它有很多的这个步骤，有很多的步骤。

### 一、从电路说起

#### 1）单个串行

- 流水线基本的这个想法是这样的，把一个过程分成若干个步骤，那就像我们前面讲的这个洗车过程，每个过程独立执行。
- 下图这个是个组合电路，完成这个操作要这个三百皮秒，操作之后要把这个结果写到这个寄存器里去，写进去是 20 个PS，从进来到写完的这个时间是 320 个PS，这就是我们的delay。

![截屏2023-03-20 23.11.39](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-20%2023.11.39.png)

#### 2）多个并行

- 那么，我们可以选择把这样一个组合电路分成三个部分，a、b、 c 。每个部分都是以 100 个PS，都是 100 个PS。但是直接分它不行，我们还要额外的插入两个寄存器，把它计算出来的这个中间结果给它留下来。
- 假如有这个i1，i2 和i3三个子操作，由于只有时钟上升的时候值才能被写进去，所以在一个时钟周期内，左边输出的这个结果不影响它右边。
- 详细来说，假如连着有两个Task来了，Task1可以分成Task1-1、Task1-2、Task1-3来执行，Task2同理，当Task1经过了下图的logicB的时候，Task2就可以进入Task2-1的处理了（此外，Task2就可以进入Task2-1的处理的输出结果不会立即写入到Reg中，因为时序电路，只有当时钟周期到了才会！），这样相当于流水线。尽管来说**单个任务的处理延时**变高了，但是同时处理的事情变多了。

![截屏2023-03-20 23.17.50](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-20%2023.17.50.png)

- 如果我们有源源不断的这个操作进去，就会看到没经过120ps的时候，就有一个任务完成！这样效率变快了。所以throughPut变成了120ps分之1，大大提高了。

所以这里就要区分和引入两个概念：

- 一个是 Latency：延迟，就是一个操作从进去到出来的时候，经过的时间延长
- 一个是 throughPut：不妨立即为吞吐量，上面的例子里面就是120ps就可以处理完成一个操作，所以两个概念使用的时间用来计算的是有差别的！需要注意区分。
- 所以流水线可以提高吞吐量，但是延迟会略微的降低！以前不是流水线的话，那它是一个做完才做第二个，，这样第一个部分一直在不断地做。
- 再次强调，寄存器的变化是有时钟周期的Rise决定的。

#### 3）不等长划分

现在，新的问题：假如不同的阶段的时间不一定相等呢！那这个时候的时钟周期就需要取最大的那一个，例如下图的，需要以150+20ps作为时钟周期。

![截屏2023-03-20 23.29.41](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-20%2023.29.41.png)

- 此外，这个时候的delay也变换了！每个阶段的时钟周期是170，也发生了变化。综上来说这种时候吞吐量就没有那么优势明显了！因为分割的时候不同阶段的分割的不是均匀的。别的硬件都在空转等待那个最长的B阶段，不划算。
- 那可不可以多分呢？分多了寄存器的数量也变多了，反而延迟也变高了！所以任何增加都需要慎重考虑。现在的流水线都很深，几十个，这样中间加的寄存器就很多了。

#### 4）存在的问题

- 我们看到这个流程线，P1、P2、P3，它们相互之间是没关系的，是独立的。但是我们在做设计计算机的时候，如果下面的情况:
- 必须等第一条指令结束以后，第二条指令才能开始执行！

```
irmovq $50, %rax        # 指令1，分为三个阶段1-1、1-2、1-3
addq %rax, %rbx         # 指令2，分为三个阶段2-1、2-2、2-3
mrmovq 100(%rbx), %rdx  # 指令3，分为三个阶段3-1、3-2、3-3
```

- 以上面的代码为例子，首先我们搞清楚一个概念！一套流水线针对的是一个指令！
- 当上面那个图中的logicA在执行指令1的1-1后，然后交给logicB执行指令1的1-2阶段
- 此时，logicA开始执行指令2的2-1阶段，这时候就出现了问题！执行1还没有执行完，rax说白了还没写入成功，这个时候就要做指令2，那rax怎么来的呢？那没办法，不好意思，指令2你给我在那等着
- 这时候就需要一个**反馈路径！**什么意思呢？就是指令1执行到了1-3就是执行完成了嘛，执行完成之后，需要手动去通知logicA模块，让他知道rax这个时候的值，然后再去进行后面的操作。如下图所示。

![截屏2023-03-21 00.18.20](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-21%2000.18.20.png)

- 原来是串行的时候，一个指令的影响就会直接传递到下一个指令，但是现在因为流水线，导致指令1的影响会传递给指令4！没有传递给指令2，这就是大寄！大寄！大寄！正确的方法应该是如下所示的图里面的**红色线**，把指令1的结果传达给指令2。但是这就矛盾了，怎么把一个未来时间的结果传到过去时间的结果呢？所以这就是问题所在！

![截屏2023-03-21 00.19.38](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-21%2000.19.38.png)

- 所以流水线看上去很好，但是出现数据依赖的时候就会出问题。

### 二、流水线实现

#### 1）SEQ+

- 首先我们需要修改更新PC的阶段(原来是在最后一步做的)，需要在一个时钟周期开始的时候执行！如下图所示
- 在原来的SEQ设计里面，我们使用的是一个new PC，PC的计算发生在时钟周期结束的时候，根据当前时钟周期内计算的信号来计算PC寄存器的新的值
- 在SEQ+里面，我们通过下图所示的pIcode、pCnd寄存器来保存一条指令执行过程中，计算出来的信号，然后**当新的时钟周期开始的时候**，这些信号值通过同样的逻辑计算当前指令的PC。
- 所以这些寄存器里面保存的是前一个周期里面产生的控制信号。

![截屏2023-03-21 13.05.13](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-21%2013.05.13.png)

- 可以发现，SEQ+没有一个严格的硬件寄存器来存放PC，它是根据上一个指令的一些信息动态的来计算PC！
- 用硬件设计语言表示如下

```
int pc= [
	picode == ICALL : pValC;
	picode == IJXX && pCnd : pValC;
	picode == IRET : pValM;
	1 : pValP;
];
```

- 然后我们把PC和Fetch阶段合并

#### 2）SEQ+示例图

- 如下所示的五个阶段，对应CPU的五级流水
- 注意：我们之前说的第一个阶段的产生的值，可能第三个阶段直接用，这是可以的，但是在流水线里面，必须要经过逐层传递。比如下图里面的Fetch阶段产生的valC，不能直接被Execute阶段直接使用，必须要逐级传递。

![截屏2023-03-21 13.13.43](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-21%2013.13.43.png)

#### 3）寄存器文件对比

- 下面我们对比SEQ和PIPE（SEQ+）设计的寄存器文件

```
#code from SEQ
int srcA = [
	icode in {IRRMOVL, IRMMOVL, 
			  IOPL, IPUSHL} : rA;
	icode in {IPOPL, IRET} : RRSP;
	1: RNONE; #Don’t need register
];
#code from PIPE
int d_srcA = [
	D_icode in {IRRMOVL, IRMMOVL, 
			    IOPL, IPUSHL} : D_rA;
	D_icode in {IPOPL, IRET} : RRSP;
	1: RNONE; #Don’t need register
];
```

- 这个图是原来的，src可以来源于rA、RRSP或者不需要寄存器

![截屏2023-03-21 13.33.46](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/%E6%88%AA%E5%B1%8F2023-03-21%2013.33.46.png)

- 现在如下所示。HCL描述如下所示

![image-20230321133604462](./4-%E6%B5%81%E6%B0%B4%E7%BA%BF.assets/image-20230321133604462.png)

```
#code from PIPE
int d_srcA = [
	D_icode in {IRRMOVL, IRMMOVL, 
			    IOPL, IPUSHL} : D_rA;
	D_icode in {IPOPL, IRET} : RRSP;
	1: RNONE; #Don’t need register
];
```

#### 4）反馈路径

- 23分24秒