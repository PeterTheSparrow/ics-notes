---
title: 第四节 调度
sidebar_position: 4
---

import OfficePreview from '@site/src/components/OfficePreview/index';

<OfficePreview place = "/ppt/3-17-sched.ppt"/>

## 第四节 调度

### 一、机制和策略

- 一个功能我们把它分成两部分，一部分就是机制，一部分是policy
- 这样划分的好处在哪？在于你的机制的这个优化改进和上面 policy 的优化和改进可以分离开来，对不对？同样的一个机制我可以用不同的policy，比如说现在Linux、windows，它的这个调度的策略一直在变化，一直在改进。
- 然后你根据不同的场景，你的手机，你的笔记本服务器、研究院实验室的这个服务器，他们可能用的都是不同的这个policy。
- 今天我们来回过来介绍呢，就是 process 的这个scheduling，它其实就是一个policy。我们关注的是你有了context switch。这项机制之后，我们要实现这个进程的调度的，这个基本的这个能力已经有了，我们能够实现了。现在问题就在于我们选择是哪一个进程执行比较合适，

### 二、FIFO(先进先出)

#### 1）假设

> 我们先做出假设，考虑最简单的场景

这五条需要同时满足下面条件，这个时候不太现实其实：

- 每个任务都运行的是相同的时间
- 所有的任务同时到达
- 一旦开始，任务运行直到结束
- 所有的任务只使用CPU，没有IO
- 我们知道所有的任务的执行的时间

#### 2）TurnAround时间

- T(turnaroun) = T(completion) − T(arrival)
- 如果基于我们上面的假设，$T(arrival)=0$

#### 3）算法解释

- 执行情况如下所示

![截屏2023-06-03 15.28.27](./4-schedule.assets/%E6%88%AA%E5%B1%8F2023-06-03%2015.28.27.png)

#### 4）取消限制

- 我们假设所有的任务可能有时间不相等的
- JobA运行100s，后面的JobB/C运行的时间10s
- 这样的平均周转时间就是(100+110+120)/3=110

![截屏2023-06-03 15.30.22](./4-schedule.assets/%E6%88%AA%E5%B1%8F2023-06-03%2015.30.22.png)

### 三、SJF(短任务优先)

- 短的任务优先执行，我们有两种情况，一种情况是不能抢占的，另外一种情况是能抢占的
- 短任务优先的衡量标准就是任务的总执行时间，我们总是选择目前任务队列里面总的执行时间最短的任务
- SJF的调度是减少turn Around的时间的最佳方法
- 但是SJF对于resp time是最糟糕的

### 四、响应时间

- 任务开始的时间-任务到达的时间就是响应时间

![截屏2023-06-03 15.36.25](./4-schedule.assets/%E6%88%AA%E5%B1%8F2023-06-03%2015.36.25.png)

### 五、Shortest Time-to-Completion First (STCF)

- 无论是什么时候，有一个新的任务到达了系统，调度都会选择一个剩余时间最短的任务去执行

### 六、Round Rabin

- 用时间片作为时间的单位
- 不断的重复任务队列里面的任务，每个任务执行的时间都是时间片的
- 这样可以减少resp time，但是可能牺牲了turnAround Time
- 时间片可能跟机器有关，如果是服务器可能时间比较长一些时间片。
- 但是不要把时间片设得太短，上下文切换也需要时间
- RR调度测试对于resp time是最好的，但是turn Aroundtime是最差的

### 七、MLFQ

- MLFQ就是多级别的反馈队列，他是在调度中进行学习啊，
- 第一条策略很简单，就是相同的情况下，我调度优先级高的，就有优先级高的先调度。
- 同一个队列里面，我们用 round Robin 
- 一个 job 进入到系统的时候，先把它放在最高优先级的，然后当你的这个 job 把这个时间片全用完了，就需要把它往下沉，你自己往下降，
- 第一个问题就是Starvation，如果一直有这个 interactive 的任务，然后他们虽然用 CPU 时间很短，但是如果数量比较多，那大家组合在一块是不会把整个 CPU 的时间全填满，
- 第二个问题，我们是所谓的 gaming。就是跟你搞一些游戏，这个就像前面说的，针对你的这个特征，我知道你的 schedule 是这么调度的，那我们是不是可以这个戏耍一下你，我明明是一个狼人领的，要用很多 CPU 的，但是我又想抢别人的，这个你别把我扔到最下面去，我想抢别人的，那么我既然知道你是通过这个放弃这个执行时间，那我是不是可以在时间片要到达前夕就把这个时间片主动放掉？反正的话还会调度给我的

它有两个策略，一个叫做 priority boost，我固定一个时间，时间到了我不管你原来是怎么样，全部重新这个重置一下。设置一个时间一到，所有的 job 你都到最上面去，你再来做，因为如果你是个狼人硬，你还是会很快的沉下去的。

至于gaming，不能单纯的去按照他最后有没有放主动放 CPU 这件事情来判断，我们去计算它到底用了多少的这个 CPU 的这个时间片，用的多就自己下去。

