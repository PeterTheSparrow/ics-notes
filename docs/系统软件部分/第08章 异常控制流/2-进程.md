---
title: 第二节 进程
sidebar_position: 2
---

import OfficePreview from '@site/src/components/OfficePreview/index';

<OfficePreview place = "/ppt/3-2-process.ppt"/>

## 第二节 进程

### 一、进程

#### 1）进程

- 进程是一个动态的概念，一段代码可以多次运行，所以可以有多个进程，所以进程是有生命周期的，它一般是你开始执行之后一直到它结束程序执行完。
- 而程序是一个静态的概念。
- 在我们的这个系统里面，进程采用的是一个树结构，它的根节点是可以认为是初始的时候创建的进行，名字叫做`init`，这样就形成了一棵树
- 如何启动一个进程？
  - 比如我们双击文件，就打开了程序，创建了一个进程
  - 通过输入可执行文件的名字，然后回车，在shell里面运行
- 进程创建之后？
  - 该进程可以在创建另外一个进程
  - 把自己的上下文装进去，然后传递给另外的进程（什么是Context？context 实际上是存在在 CPU 和内存里面的，是和这个进程相关的。因为这个进程要执行必定要用到 CPU 和内存，所以它会把东西放在 CPU 和内存上。）
  - 所有的代码其实是context，代码的一部分是一个指令流

#### 2）控制流和并发

- 程序自己的指令按照顺序排列下来，叫做虚拟的控制流
- CPU真实执行的指令流，叫做物理指令流。CPU从开机到关机，只是读取然后执行一系列的指令。这些指令可能来自不同的进程
- 并发：并发是指多个程序的，或者说两个进程他们的生命周期存在重叠，就在某一个时间会活着，有多个这个进程都活着，那么这些进程就是称为 concurrency。
- 多任务并发执行是如何实现的？
  - Interleaving：一个进程的指令流可能执行到一半就切换，然后去执行另外的一个进程。
  - VirtualAddress：虚拟地址（假如一个进程Fork了子进程，尽管里面可能某些全局变量的虚拟物理地址是一样的，但是实际的真实地址不一样）
- 如何实现Interleaving切换？
  - 上下文切换？
  - 一个进程要切换到另外一个进程的时候，需要保存一些上一个进程相关的运行状态。（典型的比如寄存器！要把这些东西保存。）然后再执行别的程序。当我要回来执行这个程序的时候，需要把上下文加载回来，然后才能继续执行。

### 二、上下文切换

#### 1）上下文

- 内核需要维护每一个进程的上下文，上下文代表进程从被中断到恢复的时候，需要加载的状态
- 上下文包括那些？我们有需要保存那些
  - 比如程序的数据、代码段，这个属于上下文，但是我们不需要额外保存，因为已经在内存里面
  - PC的值，寄存器文件、CC条件寄存器等等，这些属于上下文，更需要额外保存。因为下一个进程切换来之后，就会做更改，所以必须保持
  - 用户栈、内存栈、这些都是上下文，不需要额外保存（这些东西本来就在内存里面）但是栈顶的位置需要保存
  - 环境变量、Page Table、file Table这些都是上下文，但是不需要额外保存
- 所以Context保存的东西也不多，切换起来非常快。
- 为什么要上下文切换？因为计算机里面有很多进程在运行，计算机需要通过时间切片的方法。一般来说执行几百或者几千个指令才会上下文切换。连续执行的一段就是一个时间切片
- 最底层的我们之前介绍的硬件的这个基础，我们称为这个 exception，在这个硬件上面，操作系统在这个 exception 的这个基础上实现了 content switch，实现了 multi task 和Time slicing 这一套机制。再往上就是程序语言的机制了！C + +有一些Try和Catch机制。在语言级别是有 exception 的，本质是更高层次的异常。

#### 2）何时上下文切换

- 当程序进入到操作系统的代码去执行的时候，去执行Interrupt Handler的时候，那么这个时候你因为你在内核模式，可以去调用上下文切换。

- 也就是说程序在执行的时候是不会有机会去做 content switch 的

- 只有当程序主动调用System Call去进入到Kernel的时候，才有可能发生上下文切换

- 或者外部网络包来了，一些事情导致了中断

> 假设我写了一个`while(1)`死循环程序，会不会一直霸占CPU？
>
> - 不会，首先，中断、网络、磁盘IO都会导致上下文切换，进入到内核状态
> - 然后，有一个中断是必定会定期发生的，就是这个 time interrupt，它也在你的总线上面有个专门的硬件，这些硬件什么事情也不做，固定的时间发一个中断来打转你当前的执行，进入到Kernel
> - time interrupt 的这个间隔，有时候我们也把它称为 time slicing
> - 这样可以保证一定会进入到Kernel
> - 这样就可以保护你的程序，不会因为一个程序写错就把整个系统搞挂了

- 实际的执行可以类似这样的一个过程
- A进程先执行，然后他这边遇到一个这个 event exception，比如说你要去read，这是 system call 
- 进入到Kernel在里面做了一次 content switch，他会去唤醒，把进程 b 的代码放到 CPU 上面去执行（其实每次进入到Kernel里面，都会经过第三部分里面机制和策略里面介绍的说的调度器，经过相关判断然后决定是否切换走，切换到谁，我们这里假设切换到了B的进程）
- 执行了一会儿之后，这个时候磁盘完成了，磁盘完成的时候会发一个 interrupt 
- scheduler管理者判断当前是不是要进行切换，假设如果他想这个中断是发回给这个进程 a 的
- 然后进程A继续执行，把读取到的磁盘的信息继续处理。
- 但是在进程A的视角，好像一直就这么在执行一样

![截屏2023-04-17 20.19.47](./2-%E8%BF%9B%E7%A8%8B.assets/%E6%88%AA%E5%B1%8F2023-04-17%2020.19.47.png)



#### 3）机制和策略

- 计算机的功能分为两个部分：一个叫做机制、一个叫做策略
- 我们所说的这个 content switch 它属于机制，代表他具有这个能力，切换进程
- 但是具体来说，需要考虑策略，比如很多进程同时等待调度的时候，我需要有正确的调度策略。

> 所以，内核代码的scheduler调度者要干什么事情呢？
>
> - 需要依次执行下面的内容
> - 决定是否在进程执行期间抢占当前进程
> - 选择以前被抢占的进程（从等待调度的进程集合里面选择一个）然后继续
> - 抢占当前进程，终止当前正在执行的进程，保存当前进程的上下文
> - 重新启动刚刚选择的进程，恢复计划进程的已保存上下文，将控制权传递给此新恢复的进程

- 上面的最后两条其实是Contex，也就是机制，而前面几条就是策略的相关的内容
- 其实进入到内核是非常频繁的操作，每次进入内核其实scheduler都会经过相关逻辑判断，可能出发上下文切换，也可能没有出发上下文切换

### 三、并发

#### 1）并发

- 如下图所示，每个进程都有自己的控制流，在同一个时间之后一个进程在执行
- 进程A和进程B是并发的进程，但是进程B和进程C不是并发（因为生命周期没有覆盖）

![截屏2023-04-17 20.36.09](./2-%E8%BF%9B%E7%A8%8B.assets/%E6%88%AA%E5%B1%8F2023-04-17%2020.36.09.png)

#### 2）进程状态

- 进程有三种状态
- 运行状态：进程要目在CPU上面执行，或者在等待CPU执行，或者最终将会被调度到CPU执行（我们上面说的调度器就是从运行状态的进程组里面挑选出来的，然后去执行）
- 停止状态：执行被挂起，并且这种进程不会被调度，直到他的状态被修改为运行状态
- 终止状态：永久停止了（程序结束后，可能会有一些传递的信息，不会马上被回收。可能还会被其他程序处理才会被彻底回收）

#### 3）signal概述

- system call 是进程主动去找 OS 或者Kernel的方法，用户要进入Kernel，就要调用systemCall，当然也需要有机制从 kernel 回到user
- kernel 有一些事情要专门找这个进程的时候，这边就加入了一个机制叫做signal，
- signal有一个用途就是改变状态，如果你这个进程接收到了一个 sig stop，就会从运行状态变成Stop状态，反之如果要变成Running，需要等到接收到Sig Continue

### 三、SystemCall

- 函数它的返回值是统一的一个 Int 值，非常简单。不能花里胡哨，如果我返回一个指针，指向内核的内存地址，用户态也访问不了。
- 凡是出错，返回-1。关于出错的信息，通过error number这个全局变量返回，比如说我去这个写一个文件，你可能是因为没有权限。
- 这个全局变量并不是程序定义的，但是这个全局变量是程序可以访问的，叫做 error number，它的位置你可以简单认为在整个虚拟地址空间里面，中间的一大块是 shared library，就在那里
- 这里面会带有一个专门的号码，这个号码是代表了所有的可能的 system code 出错的信息
- 操作系统会对所有的出错 system level 的这个方式的出错进行编号，

```c
if ((pid = fork()) < 0) {
      fprintf(stderr, "fork error: %s\n", strerror(errno));
 	    exit(0);
}
```

- 所以！凡是使用SystemCall，必须手动检查返回值，或者有出错的时候要检查信息

```c
pid_t Fork(void){
 		pid_t pid;

 		if ((pid = fork()) < 0)
 			unix_error("Fork error");
 		return pid;
}
```

### 四、进程的创建和终止

#### 1）PID

- 每个进程都必须要有PID，获取进程的PID方法是
- 每个进程的PID一定是正的

```
Getpid()  // Returns the PID of the calling process 
Getppid() // Returns the PID of its parent 
// The process that created the calling process
```

- 终止程序函数

```
exit()    // 整个程序退出 
```

- 或者主函数Return的时候也终止

#### 2）Fork

- 创建子进程的方法：
- 子进程的返回值PID是0

```c
#include "csapp.h"

int main()
{
 		pid_t pid;
 		int x = 1;

 		pid = Fork();
    if (pid == 0) { /* child */
      printf("child : x=%d\n", ++x);
      exit(0);
    }

    /* parent */
    printf("parent: x=%d\n", --x);
    exit(0);
}
```

- Fork函数比较奇妙，调用一次，返回两次
- Fork返回为负数代表调用出错
- 父子进程的内存空间、栈、代码、PC都是完全一样，打开的文件描述符都是一样的！唯独不一样的就是pid的子进程是0
- 输出的时候子进程输出的是2，子进程输出的0，因为他们就相当于分家了
- 打印的顺序是随机的，可能是父进程先输出，也可能是子进程先输出，没有任何的约定。
- 注意：地址空间是复制的，但是父子进程的内存空间是独立的、互不干扰。除非事先约定好，两个进程都通过文件来通讯什么的
- Fork为什么比较高效？Fork使用了Copy on Write的机制，简单的一个想法就是这两个内容是完全一样的，那么在一开始的时候我们就不需要为你创建出来你这个子进程，可以一开始就用和父进程一样的这个东西。**只有当要进行修改的时候，在第一次修改的时候把修改的部分 copy 出来，这样的话Fork 就会非常的快**，当然这种机制会让代码复杂度增加。
- 多次执行Fork的时候，如下所示的输出结果

![截屏2023-04-17 21.16.23](./2-%E8%BF%9B%E7%A8%8B.assets/%E6%88%AA%E5%B1%8F2023-04-17%2021.16.23.png)



