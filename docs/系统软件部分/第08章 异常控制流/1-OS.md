---
title: 第一节 OS
sidebar_position: 1
---

import OfficePreview from '@site/src/components/OfficePreview/index';

<OfficePreview place = "/ppt/3-1-os.ppt"/>

## 第一节 OS

> 课程概述：我们通过计算机系统基础这门课，希望对于写的程序的本身的更深入的了解，或者说更系统性的了解，帮助大家能够写出一个正确的、高效的或者说安全的这样的一个程序。我们这节这门课叫系统软件，它包括的就主要是来支持你们应用程序执行的这个部分。我们第一节课介绍操作系统。然后介绍异常控制流。

### 一、操作系统

#### 1）概述

- 我们这边提到的操作系统更多的应该叫做内核。
- 计算机硬件系统可以抽象为：Processor、Memory、IO设备
- 我们写的程序其实并没有和硬件直接打交道，那中间会有一个gap，那这个gap就是操作系统！
- 操作系统通过抽象，可以认为它营造了另外一个环境，这个环境是你们提供给你们的运行的这个程序的
- 执行程序的时候，我们知道你打开电脑如果看后台的程序，可以看到几百个程序？但是我们写程序的时候有没有考虑到并行的程序？不需要！所以操作系统提供了一个抽象，那就是让我们的程序看上去像是机器上唯一运行的程序！我们不需要考虑什么程序要和我一块跑，跑在前面或者后面了怎么办？
- 所以！操作系统是夹在硬件和应用程序之间的，它的功能是
  - 管理硬件
  - 服务上面的应用程序
- 如下图所示

![截屏2023-04-16 22.39.00](./1-OS.assets/%E6%88%AA%E5%B1%8F2023-04-16%2022.39.00.png)

- 一般情况下操作系统我们认为是只有一个，因为一个人管才不会出问题，多个人同时使用就会出现打架的问题，你想用我也想用，就会有竞争，然后我们可能会互相产生错误的影响，你出错了会影响到别人，或者你有攻击别人的代码，有安全漏洞之类的，都会形成各种各样问题。
- 所以对于这些硬件资源来说，它需要有一个统一的管理者，就是一个操作系统

- 进一步细分，可以得到下面的图：

![截屏2023-04-16 22.42.02](./1-OS.assets/%E6%88%AA%E5%B1%8F2023-04-16%2022.42.02.png)

- 这个图是刚刚的三层的一个变形，箭头代表的是打交道的意思

- 比如说 application 直接会跑在 processor 上，虽然操作系统感觉是在硬件和你们应用程序之间有这么一层，但是它并不是说完全是一个转发，就并不是说你把你的程序，你的代码交给操系统，操作系统再把它运行在或者说经过一些处理之后再运行在处理器上。

> 为什么没有采用这种方式？这种方式操作系统完全管理下面的硬件？
>
> - 采用的两种：Processor、Main Memory被应用程序访问调用
> - IO必须经过操作系统
> - 因为CPU指令的速度非常快，主频大概10Ghz，相当于1s直接执行 $10^9$ 的指令，如果经过操作系统中间层，那效率太慢了

> 那么，操作系统让处理器怎么应对多个应用程序？
>
> - 采用的是一个分时的共享，一个处理器它在同一个时间只能执行一条指令，
> - 所以操作系统需要把不同程序的指令变成一条顺序的指令执行流

> 那么，操作系统让内存怎么应对多个应用程序？
>
> - 假如一个应用把内存A地方数据改了，然后B也把A内存区域改了？大寄！
> - 采用的是一个分片，一个程序通常不会用太多的空间，所以把内存分割开
> - 这时候操作系统就需要知道不同程序的内存区域在哪
> - 并且，保护不同进程的内存空间

> 为什么IO只能通过操作系统访问？
>
> - 第一个原因就是 IO 设备没有像 CPU 或者说处理器和内存那么快，它相对比较慢，因为你有操作系统的介入，你就需要做额外的事情，就会变慢。但是本来这个访问就很慢，在变慢也不是变得那么明显
> - 第二个原因就是因为 IO 设备很多，大家差异很大，你很难去设计出一套方法，可以适合于所有的 IO 设备，
> - 对于IO，比如显示器不太适合通过分片（内存那种方法）来管理，不可能让显示器一半显示A程序，另一半B程序。所以采用类似CPU分片的这种方法。但是USB 的这个，这个存储的设备，我们可以采用类似 Memory 的方式去做，

> 如果硬件足够简单，不需要操作系统？
>
> - 像一些单片机，比如说只跑一个程序，那你就不需要操作系统了
> - 应用的这个场景足够简单的时候，我们完全可以跳过这个操作系统这一层

#### 2）三大抽象

- 进程，是管理指令的执行
- virtual memory 就是相对于你们买的memory抽象出来的
- 然后是文件，对于IO的操作其实都是文件的抽象
- 这三个概念都是抽象概念，并不是物理实际的概念。
- 这三个都是操作系统提供的抽象，我们编写的程序其实是运行在这 3 个抽象之上的，而不是直接跑在硬件上的。
- 这三个概念和硬件的关系是什么？如下图所示
- Process并不是只针对一个处理器，而是包括Main Memory和IO设备
- 而虚拟内存包括了IO和主内存

![截屏2023-04-16 23.05.48](./1-OS.assets/%E6%88%AA%E5%B1%8F2023-04-16%2023.05.48.png)

#### 3）进程

- 写了一个程序，这个程序运行的时候就叫一个进程。一个程序可以运行多个进行，比如我开两个Word文档，这个动态的概念我们称为process。是程序的运行时。它是一个程序运行的一个实例instance，所以你一个程序可以运行多次，你也可以同时运行多个 instance 都没问题。
- 进程提供了一个假象，那就是一个环境，让你的这个运行在这个 process 里面的程序，认为整个机器都归你，自己是唯一的运行的程序
- 程序 program 里面的所有的代码，都会存贮在虚拟内存里面，然后处理器一个一个的执行。
- 一个进程的代码部分分为两个：用户代码和操作系统代码（也叫做内核，被所有的进程共享）内核部分代码在创建进程的时候，会和程序的指令打包在一块上面执行

#### 4）虚拟内存

- 上学期学的虚拟内存的分布情况如下图

- 每一个程序都会看到这样的一个虚拟的这个内存，里面的东西都类似，但是你这个内存里面不会有其他进程，就是属于你一个人的。

- 对于所有进程来说它的大小都是一样的，然后它里面放的东西从下往上，从低地址往高地址放的东西都差不多。具体的东西不一样，但类型一样。

> 虚拟内存的地址总是从0x400000开始的，为什么？（拓展问题，本书整本书都没有介绍）
>
> - 特别感谢文章：[解密虚拟内存0x400000以下的地方_Ch_ty的博客-CSDN博客](https://blog.csdn.net/u013354486/article/details/111398333)
>
> - 0X400000的地址在源码`/usr/lib/ldscripts/elf_x86_64.x`中可以找到如下定义
>
> - ```
>   PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); \
>       . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
>   ```
>
> - 对于X86-64位Linux系统而言，空出低端内存最重要的作用是为了**保证空指针可以触发访问缺失页的异常SIGSEGV，而不是访问了不该访问的资源从而导致了奇奇怪怪的问题**。可能你回好奇，为什么这里不直接从0x0000001开始做数据段呢？理论上说一个0就够用了呀？这可以归结为以下几点原因：
>
> - 考虑到多级页表的分配，省一点点不如多省一点，反正64位空间足够用，不再乎几页
>
> - 默认页大小一般是4KB，但是实际会存在很多大页机制，而大页的大小默认是4MB
>
> - 是否能少分配一点呢？答案是当然可以，只要大于65536即可。65536的规定来自于`mmap_min_addr`，可以通过`/proc/sys/vm/mmap_min_addr`查看。

- 首先是代码与指令， code 和 date 当然会分成不同的，什么 read only 的 code data，还有 read write 的，就是声明在这个全局变量有没有初始化之类的。
- 再上面的是堆，他的生长是往上的，写 malloc 相当于在堆里面开辟空间，在往上是memory mapping 的区域，是一个用户编写的共享库`#include<XXXX>`，
- 然后是栈，这就是我们很熟悉的了
- 最上面的是OS Code，红色代表程序是无法访问的

![截屏2023-04-16 23.16.34](./1-OS.assets/%E6%88%AA%E5%B1%8F2023-04-16%2023.16.34.png)

- 那么操作系统如何支持两个进程的轮流执行呢？
- 假设A进程有一部分代码A1，B进程有一部分代码B1，我们需要交替执行A1、B1
- 这些代码肯定不能直接在CPU上面执行的，中间肯定要插入一些操作系统的代码，保存上一个进程的状态。这就是OS的Code
- 每个应用程序并不能随意的去操控完全去操控这个处理器，所以操作系统不但要把它们合并在一块，还要进行一个管理和控制，就是说它的这个代码的这个级别要比应用程序的代码的级别更高，它能做所有的事情。
- 而应用程序只能做一些特定的简单的这个事情，比如说对于一些系统状态的修改，就只能由操作系统来完成。
- 这时候我们就需要对指令进行一个区分。所以就要区分KernelCode和UserCode，他们是执行在两个不同的模式的。对于 CPU 来说需要设置一个模式位， user mode 下只能执行 user code，而在Kernel mode 下它可以执行Kernel的code，KernelCode种类很多，而user mode 种类只有部分

#### 5）Virtual Memory

- 每个进程都有自己的一块 virtual memory，结构都相似，内容不一样。
- 这样就实现了在一块物理内存上面去跑多个程序，操作系统只需要把虚拟内存地址映射到逻辑物理地址
- 而对每个程序来说，它只需要在自己的 virtual memory 去分配就可以了，分配就可以了。

> 它怎么去实现一个保护呢？
>
> - 第一：因为你这边做了一个映射，所以你在自己的这个空间里面怎么分配，怎么删除，怎么去访问，都永远不会影响到另外一个进程
> - 第二个就是在 virtual memory 里面，下面这个部分是程序可以使用的，上面这个部分是被 OS code 使用的。OS code 它要在你的这个上面去执行，它也得有自己的空间，比如说它也有自己的stack，那么就是个 kernel stack，所以它这部分空间也在你的这个虚拟地址里面。这些空间是不能被应用程序访问的

#### 6）File

- 文件对应的IO设备，它就对应的是一个一个的文件。然后当一个进程要去使用这个文件的时候，它采用的方式是跟文件一样，它会去打开它，打开它之后对它进行读和写，
- 不管是什么样的IO设备，无非就是对IO设备做输入和输出，读和写。所以可以抽象为文件

### 二、异常

#### 1）异常的概念

- 我们现在这部分只关注这个进程，当然进程里面它还是会包含你这个代码和内存的，但是我们现在更多的关注的是指令怎么来实现在一个处理器上面的这个共享的这个执行。我们把这个叫做控制执行流。
- 控制执行流在程序里面会有一些变化，比如遇到`jumps`或者`call`的指令的时候。当然还会有更大的变化。比如从user code 变成 OS code或者kernel code
- 控制流里面会有些异常，例如：
  - 程序执行一半发现网络数据包来了，这时候要去写磁盘什么的
  - 程序可能写错，这边可能会有一个错误，比如除以0
- 这些都叫做异常

#### 2）System Calls

- `System Calls`和`System Return`两个指令类似我们之前说的Call和Ret，但是他可以允许更大范围可以执行的指令

![截屏2023-04-17 00.05.17](./1-OS.assets/%E6%88%AA%E5%B1%8F2023-04-17%2000.05.17.png)

- 尽管发生了切换，但是对于进程来说，他感觉自己就是一直在执行的，毫无感知

```
# hello world
int main()
{
  	write(1, "hello, world\n", 13);
 	_exit(0);
}
```

- 对应的汇编代码如下：

```
 	.section .data
 	string:
 		.ascii "hello, world\n"
 	string_end:
 		.equ len, string_end - string
 	.section .text
 	.globl main
main:
// First, call write(1, "hello, world\n", 13)
		movq 	$1, %rax 	  write is system call 1
  	movq 	$1, %rdi 	  Arg1:stdout has descriptor 1
  	movq 	$string, %rsi Arg2:Hello world string
  	movq 	$len, %rdx    Arg3:string length
  	syscall     	  Make the system call	
// Next, call exit(0)
		movq 	$60, %rax 	  _exit is system call 60
 	  movq 	$0, %rdi      Arg1:exit status is 0
   	syscall 		  Make the system call

```

- 系统调用表格如下

| **Number** | **Name** | **Desc**                          | Number | **Name** | **Desc**                    |
| ---------- | -------- | ----------------------------- | ------ | -------- | -------------------------- |
| 0          | read     | Read  a file                  | 33     | pause    | Wait  for signal           |
| 1          | write    | Write  a file                 | 37     | alarm    | Set  an alarm clock        |
| 2          | open     | Open  a  file                 | 39     | getpid   | Get process ID             |
| 3          | close    | Close  a file                 | 57     | fork     | Create  a process          |
| 4          | stat     | Get file status               | 59     | execve   | Execute  a program         |
| 9          | mmap     | Map  a file into memory       | 60     | _exit    | Terminate the process      |
| 12         | brk      | Set  the top of heap          | 61     | wait4    | Wait  for process to stop  |
| 32         | dup2     | Duplicate  a file  descriptor | 62     | kill     | Send  signal to  a process |

> - system call传递的第一个参数是用 RAX 传的，因为他要传的是一个固定的 system call number，比如说 write 是1。SystemCall只支持6个参数，不能再多了，再多一个就会爆炸！因为寄存器是不够的。而且如果通过栈来访问参数，就很麻烦。所以所有的SystemCall都经过精细的设计，保证参数比较少
> - system call的API一般只增加，不减少！

#### 3）什么时候SystemCall

- 当出现Events或者Exception的时候，调用这些 system call，改变执行流进入到KernelMode

- Event：

  - 和你当前程序有关的，比如调用了Write API
  - 还有些和你这个当前程序无关的，比如说来了一个网络包，
  - 极端情况下：按动了电源键
  - event 到达了之后就会造成整个执行流的变化，那么这个变化的过程，我们成为exception，

- Exception：

  - exception 本质上是一个硬件机制，就是说这个event来了之后，我有某一个硬件机制来帮你完成这个代码的这个切换
  - 这个切换是由硬件来完成的，它去调整了你的执行的指令流，或者准确的说就是他去改变了 EIP，就改变了当前的PC，使得下一条指令不再是你这边的指令，而可以换成了操作系统的某一条指令。
  - 执行完成之后，可能会有相应像 system return，可能会回去，但是这并不一定会回到原来的位置，比如关机了！
  - Exception最简单的一个分类就是相关和无关。
    - 和当前程序 user process 有关的，我们称为synchronize，同步的或者说related。比如程序调用了 system call，还有比如执行了除以0错误也是相关的
    - 还有些是无关的，比如说网络包来了，你按了电源键，还有一个叫时钟中断，时钟中断是不受任何干扰的，定期的发生的一个event
  - exception的处理函数叫做exception handler，他会被编号，根据异常来执行。最终的结果有三种
    - 回到错误的指令，再次执行这个错误的指令
    - 回到错误指令的下一个指令，然后继续执行
    - 终止程序，不执行了
  - exception handler的处理类似一个跳表，CPU 里面它有一个叫做 exceptional handler 的这个 base 地址，它是一个寄存器，可以认为是一个函数Function指针的这个函数的这个array，这个表里面放了好多好多的函数入口地址，你用这个 number 号和你的这个基地址进行一个组合，就能找到这个 table 的位置。这样就可以执行到handler
  - 当有异常发生的时候，硬件就会按照刚才的这个流程去调用，把 PC 指向对应的某一个函数的这个地址，然后软件使得你这个处理方式是个动态可变的，可以实现不同的这个处理方法，有不同的功能，还可以进行扩展。

#### 4）Exception

> 然后来看Exception的类型！分成了同步和异步，同步就是和你当前程序相关的，异步就是无关的。  

| 类别            | 原因               | 同步/异步 | 返回的行为                          |
| --------------- | ------------------ | --------- | ----------------------------------- |
| 中断(Interrupt) | 来自IO设备的信号   | 异步      | 总是返回到下一个指令                |
| 陷阱(Trap)      | 有意的异常         | 同步      | 总是返回到下一个指令                |
| 故障(Fault)     | 潜在可以恢复的错误 | 同步      | 可能返回到下一个指令也可能寄(举例1) |
| 终止(Abort)     | 不可以恢复的错误   | 同步      | 不会返回，终止程序                  |

- 举例1：（比如访问一个合法的数组地址空间，可能第一次访问的时候出现page fault，然后恢复处理函数会处理错误，然后在执行这个指令的时候就好了，但是如果访问一个越界的数组，那就会出现恢复处理函数处理不了，寄了直接 segmentation fault，他出错的时候，他拿到的信息是某一个地址访问出错了，所以他不知道哪一条指令出错了）

##### a）同步

- 同步的Exception还分成三类
  - 第一类是traps，就是你主动的调用，是有意的异常，是执行一条指令的结果。典型的就是SystemCall。所有的 system call 只有一个入口，它对应的是一个 exceptional handler，只是这个 exception handle 的里面，再去做一个划分，再根据你的 system call number 再去调更多的函数，是一个两级设计。从程序员的角度来看，系统调用和普通的函数调用一样，但是前者运行在用户模式，后者在内核模式。
  - 还有一些无意识的，比如说除0，分成两类， faults 和aborts，他们的区别是是否可以恢复。aborts它必定会跳转到特定的这个处理错误的这个代码，不会再回到你原来的这个进程。faults典型的例子就是page faults的情况，这种是可以恢复的。
- 所有的 exception handle 它也会在一开始被定义好，并且它的数量是固定的，是255个。有一些预先设定好的，比如除以0错误。其他的很多是动态的，比如和外设有关。比如说网络来了。但是如果机器没有网络，就没有对应的这个Handler，因为机器启动的时候就不会注册
  - 故障的例子：
    - 除法错误：应用试图除以0的时候或者除法指令的结果对于目标操作数太大的时候
    - 一般保护故障：引用了没有定义的虚拟内存区域
    - 缺页：会重新执行故障指令的异常特例

  - 终止的例子：
    - 机器检查：检测到致命的硬件错误发生的时候，DRAM或者SRAM位被破坏


##### b）异步

- 异步的这类就是和你当前程序执行无关的，比如说网络包，比如说按动电源开关之类的。在物理上面，主板上会有专门的叫做 interrupt controller 这样的一个硬件器件，当外设发生了一定的事情的时候，它会通过 interrupt controller 向 processor 发一个 event 的信号，所以我们的 processor 是插在主板上，主板插进去的时候，每个 processor 会有很多的角，我们称为pin引脚，当中有一个角会连到 interrupt controller。所以这些硬件发生事件的时候会通知到处理器调用对应的Handler。
- 异步的只有一种，那就是中断，是来自IO设备信号的结果。硬件中断的异常处理叫做中断处理程序
- 举例子：
  - IO中断包括ctrl+c、网络包的到达、data sector从硬盘到达
  - 电脑硬重启中断、软重启中断

> - IO中断是怎么实现的呢？
> - 通过I/O Port，它可以认为是一段地址，因为你 CPU 和外设之间进行操作的时候，其实是发出一些命令，你可以认为那么命令它会有一定的指向性，所有的 IO port 你可以认为是一段地址，然后不同的 IO 设备会注册在这段 port 上，CPU 就向这些 POS 发出指令。操作系统会把这些 PORT 映射到内存，对内存的读写就变成了对于这些 IO PORT 的读写

> - 举例说明读取磁盘的时候发生的中断
> - 首先 CPU 通过IO port 会向这个磁盘发出一个命令，读取什么、读取多少，读取到内存的哪里
> - 然后CPU就不需要参与了，去做其他事情了
> - 一个单独的设备叫做 DMA， direct memory access，可以不借助CPU的帮助下，直接访问内存
> - 磁盘只需要利用 DMA 就可以直接完成数据的拷贝
> - 做完了之后，硬盘需要通知CPU，告诉CPU继续执行
> - 其他网络什么的都是类似的处理逻辑，CPU比较快，所以不能让他等磁盘读取半天。

  





